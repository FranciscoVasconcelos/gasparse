.. gasparse documentation master file, created by
   sphinx-quickstart on Sun Apr  7 10:57:23 2024.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

********
gasparse
********

A python library to do computations on compiled ``C`` code using sparse representation of multivector arrays.

============
Installation
============

Installing ``gasparse`` from a stable release::

  pip install git+ssh://git@github.com/FranciscoVasconcelos/sparse-multivectors.git@v0.0.1a


The user can also install the latest development release from latest master::

  pip install git+ssh://git@github.com/FranciscoVasconcelos/sparse-multivectors.git@master

For usage of this package go to examples_. To understand about compatibility between geometric algebras see compatibility_. 
An overview of the overloaded operators that implement the different operations in geometric algebras is presented in `Table of Operators`_.

=================
Why this package?
=================

gasparse is a Geometric Algebra (GA) library which combines low level code evaluation with 
the python ``C API`` to deploy very efficient operations on multivector arrays, operations such that are easily expressed using the python syntax.

This package implements Geometric Algebras. Implements operations between multivector arrays. 
The fundamental principle behind this package is the use of overloaded operators that call optimized ``C`` functions on multivector arrays. 
The entire algebras are generated by computing the signs and bitmaps maps (the cayley table) for the binary operations. 
On calling ``gasparse.GA(p,q,r)`` the specified algebra of signature p,q,r is generated. 

There are two alternatives for dealing with Geometric Algebra `kingdon <https://github.com/tBuLi/kingdon/tree/master>`_ and `Clifford <https://github.com/pygae/clifford/tree/master>`_ they are implemented fully in python. Unlike this package they can implement symbolic computations. Because they are lazy or something, they use numba or JIT compilers and symbolic computations to do the heavy lifting for them 

List of some of the disadvantages: 
 * overhead. Because generating code is expensive
 * Code cannot be optimized further (limited by the JIT compiler)
 * Compare my approach with theirs... (show when my approach is better/worse, benchmarking)

The key points of this package are
 * Do not need to optimize code symbolically since operations are implemented in a low level language.
 * Leverage sparseness of the multivectors.
 * Do not need to use numba or other JIT compilers to speed-up numerical computations.
 * Numerical computations on multivector arrays are computed in compiled ``C`` code.
 * Multiple multivector types for which operations can be dispatched the most efficiently way possible.
 * There is compatibility between geometric algebras (can do computations between multivectors of different algebras)



.. _examples:

========
Examples
========

""""""""""""""""
A simple example
""""""""""""""""

Operations between multivector arrays are dispatched to compiled `C` code

.. doctest::

   >>> import gasparse
   >>> vga = gasparse.GA(3) # Intialize a 3D vanilla geometric algebra
   >>> x = vga.mvarray([1,2,3],grades=1)
   >>> y = vga.mvarray([4,5,6],grades=1)
   >>> print(x*y) # The product is executed in low level C code
   32 + -3*e12 + -6*e13 + -3*e23

""""""""""""""""""""""""""""
Creating geometric algebras:
""""""""""""""""""""""""""""

.. code-block:: python

	import gasparse
	vga = gasparse.GA(3)
	cga = gasparse.GA(4,1) 
	cga = gasparse.GA(metric=[-1,1,1,1,1]) 
	ga = gasparse.GA(q=3,r=4)

""""""""""""""""""""""""""""
Creating multivector arrays:
""""""""""""""""""""""""""""

.. code-block:: python

	import gasparse
	vga = gasparse.GA(3)
	locals().update(vga.basis()) # Update the global variables e, e1, e2, e3, e12, e13, e23, e123.
	values = [[0.1,1,2,3],[0.4,4,5,6]]
	x = vga.mvarray(values,grades=[0,1])
	x = vga.mvarray(values,basis=['e1','e3','e123','e12'])
	x = vga.mvarray([1,2,3,4,5,6,7,8]) # Consider all basis elements
	x = vga.mvarray(values,basis=[1, e2, e123, e23]) # Use the variables to create the multivector

Note that for the last line the basis can be any list of ``gasparse.mvarray`` with the restriction that the multivector array must be 0-dimensional.

"""""""""""""""""""""""""""""""""""""""""""""""""	
Using numpy to generate random multivector arrays
"""""""""""""""""""""""""""""""""""""""""""""""""

We can convert between numpy arrays to multivector arrays and vice versa by using lists as intermidiate data structures.
To show an example where we convert a numpy array to a multivector array we generate a random numpy array and then convert it back to a multivector array. The user has to make sure that the innermost dimension has size compatible with the specified grade in ``ga.mvarray``. To get the sizes of the grades the user can use ``ga.size(grades)``, as is exemplified in the script bellow. 
The following script generates ``5`` random multivectors of grade zero and two of the three dimensional vanilla geometric algebra.

.. doctest::

   >>> import gasparse
   >>> import numpy as np
   >>> ga = gasparse.GA(3)
   >>> arr = np.random.rand(5,ga.size(1,2)) # innermost dimension must be the the size of grades 1 and 2
   >>> print(arr)
   [[0.90962674 0.84695676 0.62962863 0.69754318 0.32404308 0.66473111]
    [0.66384851 0.74067395 0.62313971 0.40263883 0.85645313 0.06053186]
    [0.62515404 0.33892925 0.92988035 0.26066636 0.51058016 0.52560483]
    [0.71055042 0.68262854 0.40054357 0.62849844 0.56987662 0.60513613]
    [0.5360391  0.88132078 0.55923661 0.45492674 0.67648109 0.52545563]]
   >>> x = ga.mvarray(arr.tolist(),grades=[1,2]) # only accepts lists as input
   >>> print(x)
   [[0.90962674*e1 + 0.84695676*e2 + 0.62962863*e12 + 0.69754318*e3 + 0.32404308*e13 + 0.66473111*e23],
    [0.66384851*e1 + 0.74067395*e2 + 0.62313971*e12 + 0.40263883*e3 + 0.85645313*e13 + 0.060531857*e23],
    [0.62515404*e1 + 0.33892925*e2 + 0.92988035*e12 + 0.26066636*e3 + 0.51058016*e13 + 0.52560483*e23],
    [0.71055042*e1 + 0.68262854*e2 + 0.40054357*e12 + 0.62849844*e3 + 0.56987662*e13 + 0.60513613*e23],
    [0.5360391*e1 + 0.88132078*e2 + 0.55923661*e12 + 0.45492674*e3 + 0.67648109*e13 + 0.52545563*e23]]

Note that in the above example the basis elements of the multivectors are ordered by bitmaps. In the context of generating random multivectors this is irrelevant. 
But in other situations it may not be helpfull to have this mapping between lists/numpy arrays and multivector arrays as such we advise to either separate the lists into 
values of grade one and values of grade two.

.. code-block:: python

	import gasparse
	import numpy as np
	ga = gasparse.GA(3)
	arr1 = np.random.rand(5,ga.size(1))
	arr2 = np.random.rand(5,ga.size(2))
	x = ga.mvarray(arr1.tolist(),grades=1) + ga.mvarray(arr1.tolist(),grades=2)

or using `ga.basis()`

.. code-block:: python

	import gasparse
	import numpy as np
	ga = gasparse.GA(3)
	arr = np.random.rand(5,ga.size(1,2))
	basis1 = list(ga.basis(grades=1).values())
	basis2 = list(ga.basis(grades=2).values())
	x = ga.mvarray(arr.tolist(),basis=basis1+basis2)

.. _compatibility:

""""""""""""""""""""""""""""""""""""""""
Converting ``gasparse.mvarray`` to lists
""""""""""""""""""""""""""""""""""""""""

To get a list with the values of the multivectors use the function ``x.tolist(grades)`` where grades can be an integer or a list of integers ``<=p+q+r``. 
If no arguments are given then all grades are considered. **Attention: If multivectors have values in grades that are ommited in the arguments then information will be lost**. 
Example of getting lists

.. doctest::

	>>> import gasparse
	>>> ga = gasparse.GA(3)
	>>> x = ga.mvarray([[1,1,2,3],[1,4,5,6]],grades=[0,2])
	>>> print(x)
	[[1 + 1*e12 + 2*e13 + 3*e23],
	 [1 + 4*e12 + 5*e13 + 6*e23]]
	>>> values,basis = x.tolist(0,2) # returns only grades zero and two
	>>> values,basis = x.tolist([0,2]) # returns only grades zero and two
	>>> print(values,basis,sep='\n')
	[[1.0, 1.0, 2.0, 3.0], [1.0, 4.0, 5.0, 6.0]]
	[1, 1*e12, 1*e13, 1*e23]
	>>> values,basis = x.tolist() # returns a list for all grades
	>>> print(values,basis,sep='\n')
	[[1.0, 1.0, 2.0, 3.0], [1.0, 4.0, 5.0, 6.0]]
	[1, 1*e12, 1*e13, 1*e23]

	
"""""""""""""""""""""""""""""""""""""
Grade projections to the scalar grade
"""""""""""""""""""""""""""""""""""""

When multivectors are grade projected to the scalar grade (grade zero) the resulting multivector is going to be of type ``'scalar'``. 
This enables us to dispatch operations that are way more efficient e.g.

.. doctest:: 

	>>> import gasparse
	>>> from gasparse import mvarray as mv
	>>> ga = gasparse.GA(3)
	>>> x = ga.mvarray([[1,1,2,3],[1,4,5,6]],grades=[0,1])
	>>> y = x/mv.sqrt(abs((x*~x)(0)))  # normalize the mvarray
	>>> y = ~x/(x*~x)(0) # Take the inverse of the mvarray
	>>> norm_sq = (x*~x)(0) # Compute the norm square of the mvarray
	>>> print(norm_sq.type())
	GA(3).mvarray.scalar
	>>> print(norm_sq.tolist(0)[0]) # print the values as a list
	[[15.0], [78.0]]



========================================
Compatibility between Geometric Algebras
========================================

The user has to be carefull when computing operations between multivectors of different algebras. Two algebras of :math:`n` and :math:`m` dimension :math:`n<m` are compatible if the first :math:`n` elements of the metric array/tensor are equal. 
Similarly we can say that two geometric algebras are compatible if the metric tensors of both geometric algebras fully overlap with one another.
To illustrate a context where two algebras are imcompatible consider generating a 3D geometric algebra and an algebra of 4 dimensions where the first basis vector is negative and the other positives.
The following scripts shows the error obtained after attempting an operation between multivectors of incompatible algebras

.. doctest::
   
  >>> import gasparse
  >>> ga1 = gasparse.GA(metric=[1,1,1])
  >>> ga2 = gasparse.GA(metric=[-1,1,1,1])
  >>> x = ga1.mvarray([1,3,4],grades=1)
  >>> y = ga2.mvarray([2,4,7,6],grades=1)
  >>> x+y
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  TypeError: Probably Incompatible Algebras!

====================
Overloaded Operators
====================

.. _`Table of Operators`:

.. list-table:: Table of Operators
   :widths: 10 10 10
   :header-rows: 1
   :align: center

   * - Operation
     - Expression
     - Python
   * - Geometric product
     - :math:`ab`
     - :code:`a*b`
   * - Inner product
     - :math:`a \cdot b`
     - :code:`a|b`
   * - Outer product
     - :math:`a \wedge b`
     - :code:`a^b`
   * - Regressive product
     - :math:`a \vee b`
     - :code:`a&b`
   * - Divide :code:`a` by :code:`b`
     - :math:`a/b`
     - :code:`a/b`
   * - Sum :code:`a` with :code:`b`
     - :math:`a+b`
     - :code:`a+b`
   * - Subtract :code:`b` from :code:`a`
     - :math:`a-b`
     - :code:`a-b`
   * - Reverse of :code:`a`
     - :math:`a^\dagger`
     - :code:`~a`
   * - Grade projections
     - :math:`\langle a\rangle_{1,3}`
     - :code:`a(1,3)`
   * - Dual of :code:`a`
     - :math:`x^* = xI`
     - :code:`x.dual()`
   * - Undual of :code:`a`
     - :math:`x^{-*} = xI^{-1}`
     - :code:`x.undual()`



Division is only available when the second argument is either a 'scalar' type multivector array, 'float' or 'int'. The scalar product can be computed using the inner or gemetric product and projection to scalars :math:`a*b=\langle ab\rangle=\langle a\cdot b \rangle\rightarrow` :code:`(a|b)(0)` or :code:`(a*b)(0)`.
We can also use lists to project to specified grades :code:`a([1,3])`. 
Note that dualization when the pseudoscalar is null, that is :math:`I^2=0`, is defined via the relationship between the basis vectors as :math:`e_J^\dagger e_J^* = I` 
where :math:`e_J` are basis multivectors that span all the geometric algebra. The undual operation is defined as the operation that gives back the initial multivector :math:`(a^*)^{-*} = a`. 
