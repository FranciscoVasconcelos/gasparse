#include "multivector.c"

static PyMultivectorArrayObject *init_multivector_array_object(PyMultivectorArrayObject *src){
    PyMultivectorArrayObject *out = (PyMultivectorArrayObject*)PyMem_RawMalloc(sizeof(PyMultivectorArrayObject));
    out->shapes = (Py_ssize_t*)PyMem_RawMalloc(src->shape_size*sizeof(Py_ssize_t));
    out->strides = (Py_ssize_t*)PyMem_RawMalloc(src->shape_size*sizeof(Py_ssize_t));
    out->GA = src->GA;
    out->math_funcs = src->math_funcs;
    out->data_funcs = src->data_funcs;
    out->type = src->type;
    out->data_size = src->data_size;
    out->shape_size = src->shape_size;
    for(Py_ssize_t i = 0; i < src->shape_size; i++){
        out->shapes[i] = src->shapes[i];
        out->strides[i] = src->strides[i];
    }
    Py_SET_REFCNT((void*)out,1);
    Py_XINCREF((void*)src->GA);
    return out;
}

static void free_multivector_array_object(PyMultivectorArrayObject *self){
    Py_XDECREF((void*)self->GA);
    PyMem_RawFree(self->shapes);
    PyMem_RawFree(self->strides);
    PyMem_RawFree(self);
}

{% set binary_sparse_add_code %}
// code written to add two sparse multivectors

{% endset %}


{% set ns = namespace(blah=code) %}
{{ ns["blah"] }}
{% set arg_size_list = ["unary","binary","ternary"] %}

// templated for binary functions do not edit source code
{% set type_list = ["sparse","blades","dense"] %}
{% set Type_list = ["Sparse","Blades","Dense"] %}
{% set operation_list = ["add","product","reverse","grade_project"] %}
{% set op_args_list = [", sign",", ptype","",", grades, size"] %}
{% set op_type_args_list = [", int sign",", ProductType ptype","",", int *grades, Py_ssize_t size"] %}
{% set arg_size_index = [[0,1,2],[0,1,2],[0],[0]] %}


{% for i in range(3) %}
{% set type = type_list[i] %}
{% set Type = Type_list[i] %}
{% for j in range(4) %}
{% set operation = operation_list[j] %}
{% set op_args = op_args_list[j] %}
{% set op_type_args = op_type_args_list[j] %}
{% for arg_size_i in arg_size_index[j] %}

{% set arg_size = arg_size_list[arg_size_i] %}

static PyMultivectorArrayObject *{{arg_size}}_{{type}}_array_{{operation}}(
{% for k in range(arg_size_i+1) %}
    PyMultivectorArrayObject *data{{k}},
{% endfor %}
    Py_ssize_t size{{op_type_args}}){
    PyGeometricAlgebraObject *ga = left->GA;
    PyMultivectorArrayObject *out_array = init_multivector_array_object(left);
    {{Type}}Multivector *{{type}}_array = ({{Type}}Multivector*)PyMem_RawMalloc(size*sizeof({{Type}}Multivector));
{% for k in range(arg_size_i+1) %}
    {{Type}}Multivector *data{{k}}_array = ({{Type}}Multivector*)data{{k}}->data;
{% endfor %}
    Py_ssize_t i = 0;
    for(i = 0; i < size; i++){
        {{type}}_array[i] = {{arg_size}}_{{type}}_{{operation}}_(left_array[i]{{", right_array[i]" if arg_size == "binary"}}, ga{{op_args}});
        if({{type}}_array[i].size == -1)
            goto failure;
    }
    out_array->data = (void*){{type}}_array;
    return out_array;
failure:
    for(Py_ssize_t j = 0; j < i; j++) // free the other multivectors
        {{type}}_free_({{type}}_array[i]);
    PyMem_RawFree({{type}}_array);
    free_multivector_array_object(out_array);
    return NULL;
}
{% endfor %}
{% endfor %}
static void {{type}}_array_free(void *array, Py_ssize_t size){
    {{Type}}Multivector *{{type}}_array = ({{Type}}Multivector*)array;
    for(Py_ssize_t i = 0; i < size; i++)
        {{type}}_free_({{type}}_array[i]);
}

static void *{{type}}_array_init(int **bitmap, ga_float **value, Py_ssize_t *size, Py_ssize_t ssize){
    {{Type}}Multivector *{{type}}_array = ({{Type}}Multivector*)PyMem_RawMalloc(ssize*sizeof({{Type}}Multivector));
    Py_ssize_t i = 0;
    for(i = 0; i < ssize; i++){
        {{type}}_array[i] = {{type}}_init_(bitmap[i],value[i],size[i]);
        if({{type}}_array[i].size == -1)
            goto failure;
    }
    return (void*){{type}}_array;
failure:
    for(Py_ssize_t j = 0; j < i; j++) // free the other multivectors
        {{type}}_free_({{type}}_array[i]);
    PyMem_RawFree({{type}}_array);
}
{% endfor %}
